super   = getprototype(nil)
integer = getprototype(0)
decimal = getprototype(0)
string  = getprototype("")
list    = getprototype([])
map     = getprototype({})
stream  = getprototype(io.stdin)
true    = 0 < 1
false   = 1 < 0
nil     = []:remove(0)

function()
	p = super

	p.type = function(any)
		return type(any)
	end

	p.len = function(any)
		return #any
	end

end()

function()
	p = integer

	p.iterate = function(limit)
		i = 0
		return do
			if i < limit then
				return i++
			end
		end
	end

	p.max = function(a, b)
		return a > b and a or b
	end

	p.min = function(a, b)
		return a < b and a or b
	end

end()

function()
	p = decimal

	p.max = function(a, b)
		return a > b and a or b
	end

	p.min = function(a, b)
		return a < b and a or b
	end

end()

function()
	p = list

	p.push = function(list, val)
		return list:insert(#list, val)
	end

	p.pop = function(list)
		return list:remove(#list-1)
	end

	p.shove = function(list, val)
		return list:insert(0, val)
	end

	p.shift = function(list)
		return list:remove(0)
	end

	p.iterate = function(list)
		i = 0
		return do
			if i < #list then
				return i, list\i++
			end
		end
	end

	p.extend = function(list, size, def)
		while #list < size do
			list:push(def)
		end
		return list
	end

	p.set = function(list, pos, val)
		list\pos = val
	end

	p.get = function(list, pos)
		return list\pos
	end

	p.max = function(a, b)
		return #a > #b and a or b
	end

	p.min = function(a, b)
		return #a < #b and a or b
	end

end()

function()
	p = map

	p.iterate = function(m)
		i = 0
		keys = m:keys()
		return do
			if i < #keys then
				key = keys\i++
				return key, m\key
			end
		end
	end

	p.set = function(m, pos, val)
		m\pos = val
	end

	p.get = function(m, pos)
		return m\pos
	end

	p.max = function(a, b)
		return #a > #b and a or b
	end

	p.min = function(a, b)
		return #a < #b and a or b
	end

end()

function()
	ti = time.ticker(1000000)
	tick = getprototype(ti)
	ti:stop()

	tick.iterate = function(t)
		i = 0
		return do
			return i++, t:read()
		end
	end

end()

function()
	protoQueue = {

		read = function(q)
			q.lock:write()
			job = q.jobs:shift()
			q.lock:read()
			return job
		end,

		write = function(q, fn)
			q.lock:write()
			q.jobs:push(fn)
			q.lock:read()
		end,

		iterate = function(q)
			q.lock:write()
			jobs = q.jobs
			q.jobs = []
			q.lock:read()
			return do
				return jobs:shift()
			end
		end,
	}

	sync.queue = function()
		return setprototype({
				lock = sync.channel(1),
				jobs = [],
			},
			protoQueue,
		)
	end

end()

function()
	p = stream

	p.readline = function(s)
		line = []
		while ok, c = s:readrune() do
			line:push(c)
			if not c or c == '\n' then
				break
			end
		end
		return #line > 0, line:join()
	end

	p.iterate = function(s)
		done = false
		return do
			if ok, line = s:readline() then
				return line
			end
			return nil
		end
	end

end()


function()
	p = io

	p.slurp = function(path)
		if ok, file = io.open(path, "r") then
			if ok, content = file:readall() then
				file:close()
				return content
			end
		end
		return nil
	end

end()

function()
	p = getprototype(sync.channel(1))

	p.iterate = function(chan)
		return do
			return chan:read()
		end
	end
end()
