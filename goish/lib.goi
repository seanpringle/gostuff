super   = getprototype(nil)
integer = getprototype(0)
decimal = getprototype(0)
string  = getprototype("")
list    = getprototype([])
map     = getprototype({})
stream  = getprototype(io.stdin)
true    = 0 < 1
false   = 1 < 0
nil     = []:remove(0)

print = function(a...)
	for a do(i, v)
		a\i = v:string()
	end
	io.stdout:write(a:join("\t").."\n")
	io.stdout:flush()
end

log = function(a...)
	for a do(i, v)
		a\i = v:string()
	end
	io.stderr:write(a:join("\t").."\n")
	io.stderr:flush()
end

is = function(class, object)
	proto = getprototype(object)
	if type(proto) == "list" then
		for proto do(i, item)
			if item == class then
				return true
			end
		end
	end
	return class == proto
end

function()
	p = super

	p.type = function(any)
		return type(any)
	end

	p.len = function(any)
		return #any
	end

end()

function()
	p = integer

	p.iterate = function(limit)
		i = 0
		return do
			if i < limit then
				n, i = i, i+1
				return n
			end
		end
	end

	p.max = function(a, b)
		return a > b and a or b
	end

	p.min = function(a, b)
		return a < b and a or b
	end

	p.json = function(n)
		return n:text()
	end

end()

function()
	p = decimal

	p.max = function(a, b)
		return a > b and a or b
	end

	p.min = function(a, b)
		return a < b and a or b
	end

	p.json = function(n)
		return n:text()
	end

end()

function()
	p = string

	p.json = function(n)
		return n:quote()
	end

end()

function()
	p = list

	p.push = function(list, val)
		return list:insert(#list, val)
	end

	p.pop = function(list)
		return list:remove(#list-1)
	end

	p.shove = function(list, val)
		return list:insert(0, val)
	end

	p.shift = function(list)
		return list:remove(0)
	end

	p.clear = function(list)
		for #list do
			list:pop()
		end
	end

	p.iterate = function(list)
		i = 0
		return do
			if i < #list then
				n, i = i, i+1
				return n, list\n
			end
		end
	end

	p.extend = function(list, size, def)
		while #list < size do
			list:push(def)
		end
		return list
	end

	p.set = function(list, pos, val)
		list\pos = val
	end

	p.get = function(list, pos)
		return list\pos
	end

	p.max = function(a, b)
		return #a > #b and a or b
	end

	p.min = function(a, b)
		return #a < #b and a or b
	end

	p.json = function(l)
		parts = []
		for l do(i, item)
			parts:push(item:json())
		end
		return ["[", parts:join(","), "]" ]:join()
	end

end()

function()
	p = map

	p.iterate = function(m)
		i = 0
		keys = m:keys()
		return do
			if i < #keys then
				n, i = i, i+1
				key = keys\n
				return key, m\key
			end
		end
	end

	p.set = function(m, pos, val)
		m\pos = val
	end

	p.get = function(m, pos)
		return m\pos
	end

	p.max = function(a, b)
		return #a > #b and a or b
	end

	p.min = function(a, b)
		return #a < #b and a or b
	end

	p.json = function(m)
		parts = []
		for m do(k, v)
			parts:push([ k:text():quote(), ":", v:json() ]:join())
		end
		return ["{", parts:join(","), "}"]:join()
	end

end()

function()
	ti = time.ticker(1000000)
	tick = getprototype(ti)
	ti:stop()

	tick.iterate = function(t)
		i = 0
		return do
			n, i = i, i+1
			return n, t:read()
		end
	end

end()

function()
	protoQueue = {

		read = function(q)
			q.lock:write()
			job = q.jobs:shift()
			q.lock:read()
			return job
		end,

		write = function(q, fn)
			q.lock:write()
			q.jobs:push(fn)
			q.lock:read()
		end,

		iterate = function(q)
			q.lock:write()
			jobs = q.jobs
			q.jobs = []
			q.lock:read()
			return do
				return jobs:shift()
			end
		end,
	}

	sync.queue = function()
		return setprototype({
				lock = sync.channel(1),
				jobs = [],
			},
			protoQueue,
		)
	end

end()

function()
	p = stream

	p.readline = function(s)
		line = []
		while ok, c = s:readrune() do
			line:push(c)
			if not c or c == '\n' then
				break
			end
		end
		return #line > 0, line:join()
	end

	p.iterate = function(s)
		done = false
		return do
			if ok, line = s:readline() then
				return line
			end
			return nil
		end
	end

end()


function()
	p = io

	p.slurp = function(path)
		if ok, file = io.open(path, "r") then
			if ok, content = file:readall() then
				file:close()
				return content
			end
		end
		return nil
	end

end()

function()
	p = getprototype(sync.channel(1))

	p.iterate = function(chan)
		return do
			return chan:read()
		end
	end
end()
